# 并查集
## 使用场景
- 一开始每个元素都拥有自己的集合，在自己的集合里只有这个元素自己
- 时间复杂度：每个操作单次调用的均摊时间复杂度为O(1) —— 反阿克曼函数
## 类方法
- int find(a)  查找某个元素属于的类别
- bool isSameSet(a, b)  检查某两个元素是否属于同一个类别
- void Union(a, b)  合并a b两个元素（小挂大）
## 实现结构
- parent数组: 存储某个位置元素的家长节点
- size数组: 记录某个节点（作为根）时的树的大小 —— 可作为合并依据
## 优化手段
- 小挂大：依靠size数组来合并 （可以省略：和秩的概念相关） 
- 扁平化：在find过程中直接进行路径压缩

## 例题
- 例1.情侣牵手
  - 分析难度大，但是并查集的最经典应用，关键点在要想明白怎么把“交换”和“合并”做联系