//
// Created by 12472 on 25-5-25.
//
// 跳舞机有四个箭头，上下左右，要求找一个最优消耗能量最小的方案来规划踩跳舞机的路径
// 脚的动作有四种状态：
// 1. 不动，消耗1点  2. 不移动但踩了，消耗3点  3. 移动到相邻箭头，消耗5点  4. 移动到相对箭头（上到下，左到右），消耗7点
// 不合法的状态：左脚踩右箭头，右脚踩左箭头；当右脚在上下时，允许左脚踩右箭头，但这时只有等左脚移走，右脚才能动，左脚同理
// 初始状态：左脚在左箭头
// 状态定义：d(i, a, b, s)
// i表示已经踩了i个箭头，a表示左脚在哪个箭头，b表示右脚在哪个箭头，s表示上一个周期移动的脚
// (s = 0表示两脚不动，s = 1表示左脚动，s = 2表示右脚动)
// 状态转移：
// 当下一步是'.'的时候，没有箭头，三种状态：左脚动，右脚动，两个脚都不动，哪怕只移动不踩，也得输出
// d(i, a, b, s) = min{ d(i+1, a, b, 0/1/2) + cost(0, 0, 0, 0), d(i+1, a', b, 0) + cost(1, a, a', 0), d(i+1, a, b', 0) + cost(2, b, b', 0),
// d(i+1, a', b, 1) + cost(1, a, a', 1), d(i + 1, a, b', 1) + cost(2, b, b', 1), d(i+1, a', b, 2) + cost(
// 当上一步左脚动过，这一步在枚举左脚状态的时候就需要按照给定规则增加cost；
// 刷表？用d(i + 1, a, b, 0)去刷没有移动过的状态？但是怎么判断没有移动过？
// 当下一步有箭头时，有两种决策：左脚踩；右脚踩；但是注意合法性
// d(i, a, b, s) = min{d(i + 1, a', b, 1) + wei, d(i + 1, a, b, 2)}
// 边界：d(n, a, b, s) = 0
// 答案；d(0, 1, 2, 0)
#include<bits/stdc++.h>
using namespace std;
const int N = 80;


int cost(int s, int a, int na, int f)
        //上次状态 上次位置 本次位置 移动脚
{

}
